# 그리디 알고리즘

* 그리디 알고리즘은 가장 직관적인 알고리즘 설계 패러다임 중 하나이다.

매번의 선택마다 가장 최적의 결과를 도출해내자는 모토로 설계된 알고리즘 이다.

하지만 매번 무조건적으로 최선의 결과를 도출하는 것을 보장하지는 않기 때문에 문제의 성격에 따라 알고리즘을 사용하면 효율성을 높일 수 있다.

탐욕법은 다음을 가장 우선시 한다.

1. 각각의 값이 서로 다른 값에 영향을 주지 않을 것
2. 매 순간 최적의 해가 종합적으로 보았을 때도 최적의 값이어야할것

탐욕법은 재귀 호출처럼 각 단계로 쪼개어 답의 부분을 맞추어 간다는 점에서 완전탐색이나 동적계획법 알고리즘과 다를 것이 없다.
모든 선택지중 가장 최상의 답을 찾는 알고리즘이 **탐욕법(Greedy) 알고리즘이다.**


그리디 알고리즘은 주로 코테나 대회에서 최적해를 구할 수 있다는 가정하에 동적 계획법보다 빠르다는 이유로 사용되며 이외에도 근사치 값을 찾는데에도
유용하게 사용할 수 있다.


탐욕법의 개념은 간단하다. 하지만 많은 사람들의 발목을 잡는 주제 중 하나이기도 하다. 한 문제를 탐욕적으로 해결하는 방법이 한 가지만 있는 것이 아닌 경우도 많은데, 
이 중 어느 방법을 선택해야 최적해를 구할 수 있을지를 알아내기가 어렵기 때문이다. 
실제로 최적해를 얻을 수 있는 접근이 직관적이지 않기 때문에 실수에 유의해야 한다. 
그러니 그리디 알고리즘 연습 문제를 풀 때는 알고리즘의 정당성을 증명하는 과정을 빼먹지 않고 연습하는 것이 좋다.

## 그리디 알고리즘의 정당성

그리디(탐욕적) 알고리즘의 정당성 증명은 많은 경우 일정한 패턴을 가진다. 이 증명 패턴은 탐욕적인 알고리즘이 항상 최적의 값을 찾을 수 있다는 것을
증명한다. 이에 대해서는 두가지의 속성을 가진다.

1. 탐욕적 선택 속성
2. 최적 부분 구조


## 탐욕법 예제

설명하기 쉽게 탐욕법이 유용하게 사용되는 문제 중 유명한 예로 활동선택 문제 예시를 보자.
백준 1931번 회의실 배정과 같은 유형의 문제이다.

회사에 회의실이 하나 밖에 없는데 n개의 팀이 각각 회의하고 싶은 시간을 각각 제출하였을 때 두 팀이 회의실을 같이 쓸 수 없기 때문에 이 중 서로
겹치지 않는 회의들만을 골라내서 진행해야한다. 최대 몇개나 선택할 수 있을까?

![회의실](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdNu1gp%2FbtrifnLwPNl%2FR8veyh5WgwkwLFtDNs7wWK%2Fimg.png)

해당 문제의 답은 여러 방법이 존재할 수 있지만 가장 좋은 답은 서로겹치지 않게 가장 많이 선택하는 것이 좋은 답일것이다.

### 해당 문제를 무식하게 풀어보자면

무식하게 푸는 방법은 모든 부분집합을 하나하나 만들어보며 그중 회의가 겹치지 않는 답을 걸러내며 가장 큰 부분집합을 찾아내면된다.
하지만 집합의 크기가 n일때 만들어지는 부분 집합의 수는 2의N승이기 때문에 O(N2)의 시간복잡도를 가지게된다.

### 탐욕법을 사용하여 풀어보자

탐욕적으로 이 문제를 해결하려고 할때 다음과 같은 생각을 할 수 있다.

1. 길이가 짧은 회의 부터 순회하며 앞의 것과 겹치지 않는 회의들을 선택하여 최적해에 넣는다.
2. 길이와 상관없이 먼저 끝나는 것 부터 선택한다.

필자는 첫 번째 방법으로 해당 문제를 해결하려고 했다. 하지만 첫번째 방법은 그럴듯해 보이지만 짧은 회의가 긴회의 두개 사이에 위치하게 된다면
최적해에 속하지 않으므로 사용하기 부적절하다.

![짧은것부터](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FelhXX5%2FbtribzTwEQd%2F52lhFMineL1QG9kCkN1F31%2Fimg.png)

그러면 어떤 두번쨰 방법은 어떨까?

가장 먼저 끝나는 회의를 선택하고 이 회의와 겹치는 것들을 모두 지운 뒤 다시 이 중에서 먼저 끝나는 회의를 선택하기를 반복한다.

1. 회의 목록이 담긴 arr이가 주어지면 가장 일찍 끝나는 회의 arr_min을 선택한다.
2. arr_min과 겹치는 회의를 arr에서 모두 지운다.
3. arr가 텅빌 때 까지 반복한다.

탐욕적 알고리즘을 선택하면 효율적으로 알고리즘을 활용할 수 있다. 이 해당방법이 항상 최적의 해를 찾아낼 수 있다는 정당성을 두 가지 속성을 통해 증명
해주면 된다.

### 탐욕적 선택 속성을 통해 증명

처음으로 증명해야 할 속성은 동적 계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있는가 이다.
이 속성은 그리디 알고리즘에 있어 매우 중요하기 때문에 이름을 따로 붙여 탐욕적 선택 속성이라고 부른다.

탐욕적으로 선택을 하여 값을 도출 할경우 손해가 없기 때문에 탐욕적 선택 속성을 만족한다는 것은 손해가 없이 최적해를 찾을 수 있다는 것이다.

arr의 최적해 중 arr_min을 만족하는 최적해가 없다면 이 경우 첫번째의 회의를 지우고 새로운 목록을 만든다.

해당 예제는 arr_min을 포함하지 않는 예제중 하나이다.

![not](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbgAjdO%2FbtrihbjeCMM%2FRckopynBAxPgkgl7qZvTxk%2Fimg.png)

arr_min은 arr중 가장 먼저 끝나는 회의중 하나이기 때문에 지워진 회의는 arr_min보다 짧을 수 없다. 따라서 해당 최적해에서 첫번째로 개최되는 회의를 지우고
새로 추가한다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqW6gL%2FbtrifoKpNsZ%2F08C3n02gLzrKNUkWGHOSL1%2Fimg.png)

-> 따라서 두번째 회의와 arr_min은 겹치지 않고 새로 만든 목록도 최적해 중 하나가 된다.
-> 따라서 항상 arr_min을 포함하는 최적해가 존재한다. 이와 같은 증명으로 가장 일찍 끝나는 회의를 선택해서 최적해를 얻는것이 불가능해지는 경우가 없음을 나타낸다.

### 최적 부분 구조

이렇게 탐욕적인 방법으로 선택하는 것이 항상 최적의 답을 줄 수 있다고해서 증명이 끝난 것이 아니다. 항상 최적의 선택만을 내려서 전체 문제의 최적해를
얻을 수 있음을 보여야한다. 당연하지만 경우에 따라 성립하지 않은 경우도 있기 때문이다. 최적 부분 구조는 DP에서 다루듯이 부분 문제의 최적해에서
전체 문제의 최적해를 만들 수 있음을 증명해야한다.

다행히 이 속성은 대게 매우 자명해서 따로 증명할 필요가 없는 경우가 대부분이다. 첫 회의를 잘선택하고 겹치는 회의를 모두 걸러냈다면 남은 회의 중에
당연히 최대한 많은 회의를 선택하게 되므로 최적 부분 구조가 성립함을 알 수 있다.

## 구현

위의 알고리즘을 만약 그대로 적용 시킨다면 시간복잡도는 O(N2)가 되어 시간이 오래걸린다. 빠르게 구현하는 한 방법은 회의 종료시간을 오름차순으로 
정렬한 후 첫번째 회의는 가장 짧은 회의이므로 무조건 선택해도된다. 그 후 겹치는 회의와 겹치지 않는 회의를 찾으면된다.
여기서 겹치지 않는 회의를 찾으면 나머지를 보지않고 바로 선택하여도 상관없다 (어차피 오름차순으로 정렬되어있기 때문)


```java
package baekjun.greedy;

import java.util.Arrays;
import java.util.Scanner;

public class _1931 {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);

        int n = scanner.nextInt();
        int[][] arr = new int[n][2];

        for (int i=0;i<n;i++){
            arr[i][0]= scanner.nextInt();
            arr[i][1]= scanner.nextInt();
        }
        Arrays.sort(arr,(a,b)->{
            if (a[1]==b[1])return a[0]-b[0];
            return a[1]-b[1];
        });

        /*for (int i=0;i<n;i++){
            System.out.println("arr[i][0] = " + arr[i][0]);
            System.out.println("arr[i][1] = " + arr[i][1]);
        }*/

        int answer=0;
        int time=0;

        for (int i=0;i<n;i++){
            if (arr[i][0]>=time){
                time=arr[i][1];
                answer++;
            }
        }
        System.out.print(answer);
    }
}

```


## 예제2
문제 설명

점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다.
학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다.
예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다.
체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.


전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가
매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요

