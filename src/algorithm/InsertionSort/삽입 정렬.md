# 삽입 정렬(Insertion Sort)

삽입 정렬은 현재 비교하고자 하는 target과 그 이전의 원소들과 비교하며 자리를 교환(swap)하는 정렬 방법이다.

삽입 정렬은 데이터를 비교하면서 찾기 때문에 비교 정렬이며 정렬의 대상이 되는 데이터 외에 추가적인 공간이 필요하지 않기 때문에
제자리 정렬이기도하다. 정확히는 데이터를 서로 교환하는 과정(swap)에서 임시 변수를 필요로 하나 선언되는 변수의 크기가 작거나 속도에 영향을 끼치지않는다면 제자리 정렬도
판단한다. 


## 삽입 정렬 방법

삽입 정렬의 원리는 매우 간단하다. 앞에서 부터 해당 원소가 위치할 곳을 탐색하고 해당 위치에 삽입하는 것이다.

삽입정렬의 전체적인 과정은 이렇다.

1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다.(첫번째 타겟은 두번째 원소부터 비교한다.)
2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
3. 그 다음 타겟을 찾아 위와 같은 방법을 반복한다.

그림으로 보면 다음과 같다.

![InsectionSort](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FKRty3%2FbtqOKXNAGUh%2FIfdJIJDJWeAfbNDHQ6eyh0%2Fimg.png)

```java
package algorithm.InsertionSort;

public class 삽입정렬예제 {
    public static void main(String[] args) {
        int[] arr ={3,5,5,66,3,1,2,44};
        insertion_sort(arr,arr.length);
    }

    private static void insertion_sort(int[] arr, int length) {
        for (int i=1;i<arr.length;i++){
            int target=arr[i];

            int j=i-1;

            while (j>=0 && target<arr[j]){
                arr[j+1]=arr[j];
                j--;
            }

            arr[j+1]=target;
        }
    }
}
```

구현자체는 어렵지 않으며 결과적으로 타겟 이전 원소가 타겟 숫자보다 크기 직전까지 모든 숫자를 한칸씩 밀어낸다.


## 삽입 정렬 장점 및 단점

- 장점
1. 추가적인 메모리 소비가 작다.
2. 거의 정렬 된 경우 매우 효율적이다. 최선의 조건이 주어지면 O(N)의 시간 복잡도를 가진다.
3. 안정정렬이 가능하다.

- 단점
1. 역순에 가까울 수록 매우 비효율적이다. 최악의 경우 O(N2)의 시간복잡도를 가진다.
2. 데이터 상태에 따라서 성능 편차가 매우크다.

장점에 대해서 좀 더 자세히 설명하자면 타겟이 현재 리스트에서 가르키는 수보다 커질때 까지 반복문을 돌기 때문에 이미 정렬되어 있는 경우 항상 타겟숫자
그러면 값을 리스트의 길이 만큼 즉 N번만큼만 비교하면 되기 때문에 시간복잡도는 O(N)의 시간복잡도를 가지게 된다.

반대로 최악의 경우 타겟숫자가 이전숫자 보다 항상작아 N번의 숫자에 대해 N-1번 비교해야되면 O(N2)의 시간복잡도를 가진다.



## 최종 정리

삽입 정렬의 경우 거의 정렬 된 배열에서 좋은 성능을 보여 실제로 병합 정렬과 혼합한 Tim Sort이 있다. 또한 팀정렬이 프로그래밍 언어에서도 자체 라이브러리로
정렬 알고리즘에 적용하고 있는 언어들이 있다.

이후 팀 정렬을 정리할때 삽입정렬의 개념이 다시나온다. 그리고 삽입 정렬을 변형한 셸 정렬도 있다.